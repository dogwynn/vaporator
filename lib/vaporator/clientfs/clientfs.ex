defmodule Vaporator.ClientFs do
  @moduledoc """
  Monitors client-side filesystem events that
  will be synced to a cloud filesystem

  Events are processed to determine the necessary
  CloudFs sync action to be taken.

  file_system event structure:
    {:file_event, process_id, {local_path, [event]}}

  Events supported:
    - :created -> Uploads file to CloudFs
    - :modified -> Updates file in CloudFs
    - :removed -> Removes file from CloudFs
  """
  use GenServer
  require Logger

  @cloudfs %Vaporator.Dropbox{access_token: System.get_env("DROPBOX_ACCESS_TOKEN")}
  @clientfs_path Application.get_env(:vaporator, :clientfs_path)
  @cloudfs_path Application.get_env(:vaporator, :cloudfs_path)

  @doc """
  Start ClientFs filesystem monitor
  """
  def start_link() do
    GenServer.start_link(__MODULE__, [])
  end

  @doc """
  Initializes ClientFs filesystem monitor by
  starting and subscribing to FileSystem monitor
  process.

  Returns:
    {:ok, process_id}
  """
  def init(_args) do
    {:ok, pid} = FileSystem.start_link(
      dirs: [@clientfs_path],
      recursive: true
    )
    FileSystem.subscribe(pid)
    {:ok, pid}
  end

  @doc """
  Receives and handles FileSystem event messages

  Args:
    - file_event (message): Event message generated by FileSystem
      monitoring process
    - state: current state of the `GenServer`
  Returns:
    {:ok, process_id}
  """
  def handle_info({:file_event, _, {local_path, [event]}}, state) do
    process_event(event, local_path)
    {:noreply, state}
  end

  @doc """
  Determines CloudFs sync action for the
  FileSystem generated event

  Args:
    - event (atom): description of event action
    - local_path (binary): Path on client file system
  """
  def process_event(:created, local_path) do
    IO.puts("Created -> #{local_path}")
    case File.dir?(local_path) do
      true ->
        IO.puts("Create folder in CloudFs")
        # TODO: Add folder creation to
        # Vaporator.Dropbox
      false ->
        Vaporator.CloudFs.file_upload(
          @cloudfs,
          local_path,
          @cloudfs_path
        )
    end
    
  end

  def process_event(:modified, local_path) do
    # :created events also trigger a :modified event
    # Checking if created and modified time are the same
    # to determine if cloudfs needs to be updated
    # TODO: Need to update this check since stats.ctime means
    # something different on varying operating systems
    # i.e. ctime is created on Windows, but last written on Unix
    stats = File.lstat!(local_path)
    modified_event? = stats.ctime == stats.mtime
    if not modified_event? do
      IO.puts("Modified -> #{local_path}")
      Vaporator.CloudFs.file_update(
        @cloudfs,
        local_path,
        Path.join(@cloudfs_path, Path.basename(local_path))
      )
    end
  end

  def process_event(:renamed, local_path) do
    IO.puts("Renamed -> #{local_path}")
    # TODO: Figure out how to rename files in CloudFs
    # Currently depend on local_path.basename to know which
    # file to update in CloudFs
  end

  def process_event(:removed, local_path) do
    IO.puts("Deleted -> #{local_path}")
    case File.dir?(local_path) do
      true ->
        Vaporator.CloudFs.folder_remove(
          @cloudfs,
          Path.join(@cloudfs_path, Path.dirname("#[local_path}/"))
        )
      false ->
        Vaporator.CloudFs.file_remove(
          @cloudfs,
          Path.join(@cloudfs_path, Path.basename(local_path))
        )
    end
  end

  def process_event(event, _) do
    {:error, {:unhandled_event, event}}
    Logger.error("[error] Unhandled event -> #{event}")
  end

end